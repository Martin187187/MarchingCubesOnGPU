#pragma kernel March
#include "Includes/MarchTables.compute"

struct Vertex
{
	float3 position;
	float3 normal;
	uint data;
};

struct Triangle
{
	Vertex a;
	Vertex b;
	Vertex c;
};

struct Voxel
{
	int type;
	float iso;
};
AppendStructuredBuffer<Triangle> vertices;
RWStructuredBuffer<int> counter;
StructuredBuffer<Voxel> voxelGrid;

int gridSize;
float isoLevel;

float3 interpolateVerts(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz-v1.xyz);
    //return (v1.xyz + v2.xyz)/2;
}

uint3 calculatePosition(int index) {
	uint n = gridSize;
	uint z = index / (n * n);
	uint y = (index % (n * n)) / n;
	uint x = index % n;
	return uint3(x, y, z);
}


int type(Voxel a, Voxel b){
    if(a.iso<b.iso){
        return a.type;
    }
    return b.type;
}
int indexFromCoord(int3 v) {
    return v.z * gridSize * gridSize + v.y * gridSize + v.x;
}

float3 calculateNormal(int3 coord) {
	int3 offsetX = int3(1, 0, 0);
	int3 offsetY = int3(0, 1, 0);
	int3 offsetZ = int3(0, 0, 1);
    
    float dx;
    float dy;
    float dz;
    if(coord.x == 0 || coord.x == gridSize-1)
	    dx = 0;
    else
	    dx = voxelGrid[indexFromCoord(coord + offsetX)].iso - voxelGrid[indexFromCoord(coord - offsetX)].iso;
    if(coord.y == 0 || coord.y == gridSize-1)
	    dy = 0;
    else
	    dy = voxelGrid[indexFromCoord(coord + offsetY)].iso - voxelGrid[indexFromCoord(coord - offsetY)].iso;
    if(coord.z == 0 || coord.z == gridSize-1)
	    dz = 0;
    else
	    dz = voxelGrid[indexFromCoord(coord + offsetZ)].iso - voxelGrid[indexFromCoord(coord - offsetZ)].iso;
    
    if(dx == 0 && dy == 0 && dz == 0)
        return normalize(float3(1,1,1));
	return normalize(float3(dx, dy, dz));
}



Vertex createVertex(int3 coordA, int3 coordB, int indexA, int indexB, Voxel vA, Voxel vB) { 

	// Interpolate between the two corner points based on the density
	float t = (isoLevel - vA.iso) / (vB.iso - vA.iso);
	float3 position = coordA + t * (coordB - coordA);

	// Normal:
	float3 normalA = calculateNormal(coordA);
	float3 normalB = calculateNormal(coordB);
	float3 normal = -normalize(normalA + t * (normalB - normalA));

	// Compute the triplanar UVs based on the dominant normal axis
	float2 uvX = position.yz / gridSize; // X-axis projection
	float2 uvY = position.xz / gridSize; // Y-axis projection
	float2 uvZ = position.xy / gridSize; // Z-axis projection

	// Blend factors based on the dominant normal axis
    float3 absNormal = normal;
	float weightX = absNormal.x / (absNormal.x + absNormal.y + absNormal.z);
	float weightY = absNormal.y / (absNormal.x + absNormal.y + absNormal.z);
	float weightZ = absNormal.z / (absNormal.x + absNormal.y + absNormal.z);

	// Combine the UVs for triplanar mapping by blending
	float2 uv = uvX * weightX + uvY * weightY + uvZ * weightZ;

	// Create vertex and set attributes (position, normal, UV)
	Vertex vertex;
	vertex.position = position;
	vertex.normal = normal;
	vertex.data = type(vA, vB); // Assuming `type` is your method for additional data
    
	return vertex;
}
[numthreads(4,4,4)]
void March (int3 id : SV_DispatchThreadID)
{   
    // Stop one point before the end because voxel includes neighbouring points
    if (id.x < 1 || id.y < 1 || id.z < 1 || id.x >= gridSize-2 || id.y >= gridSize-2 || id.z >= gridSize-2) return;
    

    // 8 corners of the current cube
    int3 cubeCorners[8] = {
        int3(id.x, id.y, id.z),
        int3(id.x + 1, id.y, id.z),
        int3(id.x + 1, id.y, id.z + 1),
        int3(id.x, id.y, id.z + 1),
        int3(id.x, id.y + 1, id.z),
        int3(id.x + 1, id.y + 1, id.z),
        int3(id.x + 1, id.y + 1, id.z + 1),
        int3(id.x, id.y + 1, id.z + 1)
    };

    int cubeIndexCorners[8] = {
        indexFromCoord(cubeCorners[0]),
        indexFromCoord(cubeCorners[1]),
        indexFromCoord(cubeCorners[2]),
        indexFromCoord(cubeCorners[3]),
        indexFromCoord(cubeCorners[4]),
        indexFromCoord(cubeCorners[5]),
        indexFromCoord(cubeCorners[6]),
        indexFromCoord(cubeCorners[7])
    };

    Voxel cubeDataCorners[8] = {
        voxelGrid[cubeIndexCorners[0]],
        voxelGrid[cubeIndexCorners[1]],
        voxelGrid[cubeIndexCorners[2]],
        voxelGrid[cubeIndexCorners[3]],
        voxelGrid[cubeIndexCorners[4]],
        voxelGrid[cubeIndexCorners[5]],
        voxelGrid[cubeIndexCorners[6]],
        voxelGrid[cubeIndexCorners[7]]
    };

    // Calculate unique index for each cube configuration.
	// There are 256 possible values (cube has 8 corners, so 2^8 possibilites).
	// A value of 0 means cube is entirely inside the surface; 255 entirely outside.
	// The value is used to look up the edge table, which indicates which edges of the cube the surface passes through.
	int cubeConfiguration = 0;
	for (int i = 0; i < 8; i ++) {
		// Think of the configuration as an 8-bit binary number (each bit represents the state of a corner point).
		// The state of each corner point is either 0: above the surface, or 1: below the surface.
		// The code below sets the corresponding bit to 1, if the point is below the surface.
		if (cubeDataCorners[i].iso < isoLevel) {
			cubeConfiguration |= (1 << i);
		}
	}
	
	// Get array of the edges of the cube that the surface passes through.
	int edgeIndices[16] = triangulation[cubeConfiguration];

	// Create triangles for the current cube configuration
	for (int n = 0; n < 16; n += 3) {
		// If edge index is -1, then no further vertices exist in this configuration
		if (edgeIndices[n] == -1) { break; }

		// Get indices of the two corner points defining the edge that the surface passes through.
		// (Do this for each of the three edges we're currently looking at).
		int edgeIndexA = edgeIndices[n];
		int a0 = cornerIndexAFromEdge[edgeIndexA];
		int a1 = cornerIndexBFromEdge[edgeIndexA];

		int edgeIndexB = edgeIndices[n+1];
		int b0 = cornerIndexAFromEdge[edgeIndexB];
		int b1 = cornerIndexBFromEdge[edgeIndexB];

		int edgeIndexC = edgeIndices[n+2];
		int c0 = cornerIndexAFromEdge[edgeIndexC];
		int c1 = cornerIndexBFromEdge[edgeIndexC];
        // Calculate positions of each vertex.
		Vertex vertexA = createVertex(cubeCorners[a0], cubeCorners[a1], cubeIndexCorners[a0], cubeIndexCorners[a1], cubeDataCorners[a0], cubeDataCorners[a1]);
		Vertex vertexB = createVertex(cubeCorners[b0], cubeCorners[b1], cubeIndexCorners[b0], cubeIndexCorners[b1], cubeDataCorners[b0], cubeDataCorners[b1]);
		Vertex vertexC = createVertex(cubeCorners[c0], cubeCorners[c1], cubeIndexCorners[c0], cubeIndexCorners[c1], cubeDataCorners[c0], cubeDataCorners[c1]);
		
		Triangle tri;
		tri.a = vertexA;
		tri.b = vertexB;
		tri.c = vertexC;

		vertices.Append(tri);
		InterlockedAdd(counter[0], 3);
    }


}
