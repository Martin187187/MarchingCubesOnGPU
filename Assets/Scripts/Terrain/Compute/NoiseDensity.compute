#pragma kernel Density
#include "Noise.compute"
#include "Structure.compute"


RWStructuredBuffer<Voxel> voxels;

int numPointsPerAxis;
float chunkSize;

// Noise settings
float3 chunkPosition;
float3 offset;
int octaves;
float lacunarity;
float persistence;
float noiseScale; 
float noiseWeight;
float floorOffset; 
float weightMultiplier;
float hardFloor;
float hardFloorWeight;

float4 params = float4(1,0,0,0);
    
int val;
float isoLevel;
float sigmoid(float x, float a) {
    return 1.0 / (1.0 + exp(-a * x));
}



int indexFromCoord(uint x, uint y, uint z) {
    return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
}



[numthreads(numThreads,numThreads,numThreads)]
void Density (int3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }
    float spacing = chunkSize / (float)(numPointsPerAxis-3);
    float3 pos = (id-1) * spacing + chunkPosition;
    float offsetNoise = 0;

    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = 1;
    float weight = 1;
    for (int j =0; j < octaves; j ++) {
        float n = snoise((pos+offsetNoise) * frequency + offset);
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = max(min(v*weightMultiplier,1),0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    float finalVal = -(pos.y + floorOffset) + noise * noiseWeight ;

    if (pos.y < hardFloor) {
        finalVal += hardFloorWeight;
    }

    int index = indexFromCoord(id.x,id.y,id.z);

    float iso = sigmoid(finalVal, 0.1);
    if (iso > isoLevel)
    {
        voxels[index].type = val;
    }
        voxels[index].iso =  max(voxels[index].iso, iso);
    
    
}
